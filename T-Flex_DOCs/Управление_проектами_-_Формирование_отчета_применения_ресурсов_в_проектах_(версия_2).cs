using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using TFlex.DOCs.Model.Macros;
using TFlex.DOCs.Model.Macros.ObjectModel;
using TFlex.DOCs.Model.References.Files;

//Библиотека для работы с excel
using Excel = Microsoft.Office.Interop.Excel;

public class Macro : MacroProvider
{
    public Macro(MacroContext context)
        : base(context)
    {
    }
    

    private string pathToReport = @"C:\tflexcash\Состав работ.xlsx";

    bool debug = false;

    public override void Run()
    {
        // Данный макрос предназначен для составления отчета для модуля проектирования. Вызываться макрос будет из справочника Ресурсы.
        // Основаная задача - отображдение текущей задействованности ресурсов в проектах

        // Получаем выбранное подразделение
        Объект подразделение = ТекущийОбъект;

        // Получаем список всех человеческих ресурсов
        List <Объект>человеческиеРесурсы = ПолучитьСотрудниковПодразделения(подразделение);
        
        
        string message = "";

        /*
        // Опциональный блок, предназначен для отображения всех человекоресурсов, входящих в выбранное подразделение 
        foreach (Объект ресурс in человеческиеРесурсы)
        {
            message += ресурс.ToString() + "\n";
        }
        Сообщение("Сотрудники выбранного подразделения", message);
        */


        // Получение всех корневых проектов справочника "Управление проектами". Данная операция проводится для составления ограничивающего списка проектов
        // (проекты, которые в этот список не входят, не будут отображаться в сформированном отчете)
        List<Объект> всеПроекты = ПолучитьВсеКорневыеПроектыУправленияПроектами();

        #region DEBUG. Печать всех корневых объектов
        if (debug == true)
        {
            foreach(Объект проект in всеПроекты)
            {
                message = message + проект.Параметр["Наименование"].ToString() + "\n";
            }
            Сообщение ("DEBUG. Список всех корневых проектов", message);
            message = "";
        }
        #endregion
        
        // Получения данных для фильтрации результата
        ДиалогВвода данныеОтПользователя = ПолучитьДатуОтПользователя();

        if (данныеОтПользователя == null) return;

        #region DEBUG. Печать введенных пользователем дат
        if (debug == true)
        {
            Сообщение("DEBUG. Введенные пользователем даты", String.Format("Начало диапазона: {0}; Конец диапазона: {1}", данныеОтПользователя["Дата начала"], данныеОтПользователя["Дата окончания"]));
        }
        #endregion

        List<string>пространстваПланирования = ПолучитьСписокПространствПланированияОтПользователя();

        #region DEBUG. Печать значения списка пространств имен
        if (debug == true)
        {
            foreach (string пространствоПланирования in пространстваПланирования)
            {
                message = message + пространствоПланирования + "\n";
            }
            Сообщение("DEBUG. Список выбранных пространств планирования", message);
            message = "";
        }
        #endregion

        if (пространстваПланирования == null) return;

        // Далее, получаем список всех проектов верхнего уровня для того, чтобы в дальнейшем его
        // можно было отфильтровать по введенным ранее значениям

        // Отфильтровываем список корневых проектов
        List<string> отфильтрованныеПроекты = new List<string>();

        foreach (Объект проект in всеПроекты)
        {
            #region DEBUG. Печать проекта и его пространства планирования
            if (debug == true)
            {
                Сообщение("DEBUG. Проект и его пространство планирования",
                String.Format(  "Проект: {0}; Пространство планирования: {1}",
                                проект.Параметр["Наименование"],
                                проект.Параметр["Пространство планирования"].ToString()));
            }
            #endregion
            
            // Фильтрация по признаку пространства планирования
            if (пространстваПланирования.Contains(проект.Параметр["Пространство планирования"].ToString()))
            {
                #region DEBUG. Печать даты начала и даты окончания проекта
                if (debug == true)
                {
                    Сообщение("DEBUG. Даты проекта", String.Format("{0}, {1}, {2}", проект.Параметр["Наименование"], проект.Параметр["Начало"], проект.Параметр["Окончание"]));
                }
                #endregion
                
                // Проверка по признаку даты
                if (СовпалДиапазонДат(проект.Параметр["Начало"], проект.Параметр["Окончание"], данныеОтПользователя["Дата начала"], данныеОтПользователя["Дата окончания"]))
                {
                    отфильтрованныеПроекты.Add(проект.Параметр["Наименование"].ToString());
                }
            }
        }

        #region debug (first filtration of list of project)
        if (debug == true)
        {
            foreach (string проект in отфильтрованныеПроекты)
            {
                message = message + проект + "\n";
            }
            Сообщение("DEBUG. Список отфильтрованных проектов", message);

            message = "";
        }
        #endregion


        
        отфильтрованныеПроекты = ОтфильтроватьПроектыПользовательскимВводом(отфильтрованныеПроекты);

        if (отфильтрованныеПроекты == null) return;
      
      
        // Код для сбора данных, которые входят в проекты, связанные с данными исполнителями
        // Инициализируем список с типом данных Data, в котором будут храниться все данные
        List<Data> таблицаДанных = new List<Data>();

        // Далее, осуществляем перебор значений
        foreach (Объект работник in человеческиеРесурсы)
        {
            // Получаем проекты, к которым подключен данный работник
            Объекты используемыеРесурсы = работник.СвязанныеОбъекты["Используемый ресурс"];
            foreach (var сотрудник in используемыеРесурсы)
            {
                Объект работа = сотрудник.СвязанныйОбъект["Проект"];
                
                
                // В данной строчке нужно будет ввести проверку, чтобы дальнейший код выполнялся только для тех проектов
                // которые входят в список отфильтрованных
                
                if (РаботаВходитВОтфильтрованныеПроекты(работа, отфильтрованныеПроекты))
                {
                    // Проверка на тип работы. Если работа относится к типу "проект", то используется она. Если работа относится к любому другому типу, то использоваться должна
                    // родительская работа, имеющая тип "Проект".

                    // Инициализируем строку с данными (каждый раз мы инициализируем новый объект)


                    if (данныеОтПользователя["Выполненные работы 100%"] == true)
                    {
                        Data строка = СформироватьСтрокуТаблицыДанных(сотрудник, работа);
                        // Далее, добавляем сгенерированную строку в таблицуДанных
                        таблицаДанных.Add(строка);

                    }
                    else
                    {
                        // Если отображение выполненных работ отключено, тогда мы проверяем каждую работу на 100% завершение и включаем в отчет только те работы, которые пройдут проверку
                        if ((работа.Параметр["Процент выполнения"] * 100).ToString() != "100")
                        {
                            Data строка = СформироватьСтрокуТаблицыДанных(сотрудник, работа);
                            // Далее, добавляем сгенерированную строку в таблицуДанных
                            таблицаДанных.Add(строка);
                        }
                    }
                }
            }
        }
        
        if (СформироватьФайлОтчетаВФорматеExcel(таблицаДанных))
        {
            Сообщение("Информация", "Отчет был успешно сформирован");
        };
    }

    private Data СформироватьСтрокуТаблицыДанных(Объект сотрудник, Объект работа)
    {
        Data строка = new Data();
                        
        Объект временныйОбъект = null;

        if (работа.Параметр["Тип"].ToString() == "Проект")
        {
            временныйОбъект = работа;
        }
        else
        {   
            временныйОбъект = ПолучитьРодителяПоТипу(работа, "Проект") != null ? ПолучитьРодителяПоТипу(работа, "Проект") : работа;
        }


        if (временныйОбъект.Параметр["Пространство планирования"].ToString() != "00000000-0000-0000-0000-000000000000")
        {
            Объект пространствоПланирования = НайтиОбъект("Пространства планирования", String.Format("[guid] = '{0}'", временныйОбъект.Параметр["Пространство планирования"].ToString()));

            строка.видРабот = пространствоПланирования.Параметр["Наименование"].ToString();
        }
        else строка.видРабот = "";



        строка.фио = сотрудник.ToString();
        строка.заказчик = работа.Параметр["Описание"].ToString();
        строка.корневойПроект = получитьКорневойПроектРаботы(работа).Параметр["Наименование"].ToString();
        строка.наименованиеРодителя = работа.РодительскийОбъект != null ? работа.РодительскийОбъект.Параметр["Наименование"].ToString() : работа.Параметр["Наименование"].ToString();
        строка.наименованиеРабот = работа.Параметр["Наименование"].ToString();
        строка.процентВыполнения = (работа.Параметр["Процент выполнения"] * 100).ToString();
        строка.начало = работа.Параметр["Начало"];
        строка.окончание = работа.Параметр["Окончание"];
        строка.датаПоследнегоИзменения = работа.Параметр["Дата последнего изменения процента выполнения"];

        return строка;
    }

    private bool РаботаВходитВОтфильтрованныеПроекты(Объект работа, List<string> отфильтрованныеПроекты)
    {
        // функция возвращает true, если работа входит является прямым или непрямым потомком любого проекта из переданного списка, в обратном случае возвращает false
        while (true)
        {
            if (отфильтрованныеПроекты.Contains(работа.Параметр["Наименование"]))
            {
                return true;
            }

            работа = работа.РодительскийОбъект;
            if (работа == null)
            {
                return false;
            }
        }

        return false;
    }

    private bool СовпалДиапазонДат(DateTime началоПроекта, DateTime конецПроекта, DateTime началоФильтр, DateTime конецФильтр)
    {
        if ( ((началоПроекта.CompareTo(началоФильтр) >= 0) & (началоПроекта.CompareTo(конецФильтр) <= 0 )) || ((конецПроекта.CompareTo(началоФильтр) >= 0) & (конецПроекта.CompareTo(конецФильтр) <= 0)))
        {
            return true;
        }

        if ((началоФильтр.CompareTo(началоПроекта) >= 0) & (началоФильтр.CompareTo(конецПроекта) <= 0))
        {
            return true;
        }
        
        return false;
    }
    
    private List<Объект> ПолучитьВсеКорневыеПроектыУправленияПроектами()
    {
        // Данная функция предназначена для получения списка корневых проектов из справочника Управления Проектами
        // Данную операцию можно сделать, получив все Проекты данного справочника, а потом проследив их родителей.
        // Но возможно можно поступить иначе - сначала получить справочник, потом получить все его дочерние объекты,
        // если такое возможно, и у каждого объекта получить его дочерние подключения, если тип этого объекта - не проект, а, допустим, папка


        // Далее, получаем все дочерние подключения первого уровня
        Объекты ВсеОбъектыТипаПроект = НайтиОбъекты("Управление проектами", "Тип", "Проект");

        List<Объект>КорневыеПроекты = new List<Объект>();

        // Отбираем из списка всех проектов только корневые проекты
        foreach (Объект проект in ВсеОбъектыТипаПроект)
        {
            if ((проект.РодительскийОбъект == null) || (проект.РодительскийОбъект.Параметр["Тип"] == "Папка"))
            {
                КорневыеПроекты.Add(проект);
            }
        }


        return КорневыеПроекты;
        
    }

    private Объект получитьКорневойПроектРаботы(Объект работа)
    {
        // Данный метод предназначен для получения корневого проекта по данной работе
        while (true)
        {
            if ((работа.РодительскийОбъект == null) || (работа.РодительскийОбъект.Параметр["Тип"] == "Папка")) break;
            работа = работа.РодительскийОбъект;
        }

        return работа;
    }
    private ДиалогВвода ПолучитьДатуОтПользователя()
    {
        // Данный метод предназначен для отрисовки диалога ввода. Возвражает метод заполненный пользователем диалов ввода
        // для передачи заполненных данных в основной метод данного макроса

        ДиалогВвода пользовательскийВвод = СоздатьДиалогВвода("Выберите даты");

        // Ввод дат
        пользовательскийВвод.ДобавитьТекст("Введите даты для отображения только тех проектов, которые попали на данный горизонт планирования:", 2);
        пользовательскийВвод.ДобавитьДату("Дата начала", DateTime.Now);
        пользовательскийВвод.ДобавитьДату("Дата окончания", DateTime.Now);

        // Добавление флага, которые будет отвечать за включение или отключение выполненных работ из отчета
        пользовательскийВвод.ДобавитьФлаг("Выполненные работы 100%", true, false);
        if (пользовательскийВвод.Показать())
        {
            return пользовательскийВвод;
        }
        
        else
        {
            return null;
        }
        ;
        
    }

    private List<string> ПолучитьСписокПространствПланированияОтПользователя()
    {
        // Для начала получаем перечень всех пространств имен, которые есть в базе данных

        Объекты пространстваПланирования = НайтиОбъекты("Пространства планирования", "Тип", "Пространство планирования");

        // Инициализируем диалог ввода
        ДиалогВвода пользовательскийВвод = СоздатьДиалогВвода("Выберите вид работ");

        foreach (var пространство in пространстваПланирования)
        {
            пользовательскийВвод.ДобавитьФлаг(пространство.Параметр["Наименование"], false);
        }

        // Добавления флага для выбора или исключения проектов, в которых не заполнена графа с выбором пространства планирования
        пользовательскийВвод.ДобавитьФлаг("Проекты без вида работ", false);

        if (!пользовательскийВвод.Показать())
        {
            return null;
        }

        // Собираем отмеченные пользователем в диалоге пространства планирования
        // Инициализирую список с названиями пространств планирования
        List<string> выбранныеПространстваПланирования = new List<string>();
        foreach (var пространство in пространстваПланирования)
        {
            if (пользовательскийВвод[пространство.Параметр["Наименование"]] == true)
            {
                выбранныеПространстваПланирования.Add(пространство.Параметр["Guid"].ToString());
            }
        }
        // Добавление в переменную с пространствами планирования значения для выбора проектов без указанного пространства планирования
        if (пользовательскийВвод["Проекты без вида работ"] == true)
        {
            выбранныеПространстваПланирования.Add("00000000-0000-0000-0000-000000000000");
        }
        return выбранныеПространстваПланирования;
    }
    
    private List<string> ОтфильтроватьПроектыПользовательскимВводом(List<string> отфильтрованныеПроекты)
    {
        ДиалогВвода пользовательскийВвод = СоздатьДиалогВвода();

        List<string> возвращенныйСписокПроектов = new List<string>();

        пользовательскийВвод.ДобавитьТекст("Выберите проекты, работы которых должны войти в отчет", 2);

        foreach (string проект in отфильтрованныеПроекты)
        {
            пользовательскийВвод.ДобавитьФлаг(проект, true, false);
        }

        if (пользовательскийВвод.Показать())
        {
            foreach(string проект in отфильтрованныеПроекты)
            {
                if (пользовательскийВвод[проект] == true)
                {
                    возвращенныйСписокПроектов.Add(проект);
                }
            }
            return возвращенныйСписокПроектов;
        }
        else return null;
    }

    private bool СформироватьФайлОтчетаВФорматеExcel(List<Data> табличныеДанные)
    {
        // Генерируем файл, в который будет сохраняться отчет (если создать его не получилось, завершаем работу)
        ДиалогОжидания.Показать("Подождите, идет формирование отчета", true);
        ДиалогОжидания.СледующийШаг("Создание отчета из шаблона");
        if (!СоздатьФайлОтчета(pathToReport)) return false;
    
        // Работа с приложением Excel
        // Указываем имя явно, так как класс Application так же есть в другой библиотеке, которую я тут использую
        ДиалогОжидания.СледующийШаг("Запуск приложения Excel");
        Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();

        // Дальше нужно произвести открытие файла
        excel.Workbooks.Open(pathToReport);

        // Получаем первый лист, с которым будем производить работу
        Excel.Worksheet sheet = (Excel.Worksheet)excel.Worksheets.get_Item(1);

        // Можно присвоить листу свое имя
        sheet.Name = "Состав работ";
        ДиалогОжидания.СледующийШаг("Заполнение ячеек данными");
        // Заполнение ячеек

        // Инициализация переменных, в которых будут храниться индексы ячеек
        int i = 2;
        foreach (Data строка in табличныеДанные)
        {
            sheet.Cells[i, 1] = строка.видРабот;
            sheet.Cells[i, 2] = строка.фио;
            sheet.Cells[i, 3] = строка.заказчик;
            sheet.Cells[i, 4] = строка.корневойПроект;
            sheet.Cells[i, 5] = строка.наименованиеРодителя;
            sheet.Cells[i, 6] = строка.наименованиеРабот;
            sheet.Cells[i, 7] = строка.датаПоследнегоИзменения;
            sheet.Cells[i, 8] = строка.процентВыполнения;
            sheet.Cells[i, 9] = строка.начало;
            sheet.Cells[i, 10] = строка.окончание;
            ДиалогОжидания.СледующийШаг("Заполнение строки " + (i - 1));

            i++;
        }

        // Делаем приложение видимым после того, как все данные в него будут внесены
        ДиалогОжидания.Скрыть();
        excel.Visible = true;

        return true;

    }

    private bool СоздатьФайлОтчета(string pathToSaveReport)
    {
        // Получаем доступ к файлу шаблона отчета для получения пути его расположения на локальном компьютере
    	FileObject шаблон = (FileObject)НайтиОбъект("Файлы", "[Наименование] = 'Шаблон отчёта - Ресурсы по проектам.xlsx'");
        
        // Если шаблон не найден, выдаем сообщение об ошибке, после чего прекращаем выполнение программы
        if (шаблон == null)
        {
            Сообщение("Ошибка","Файл шаблона отчета не был найден");
            return false;
        }

        // Выгружаем файл шаблона для последующего его заполнения данными
        шаблон.Export(pathToSaveReport, true);

        return true;
    }

    private Объект ПолучитьРодителяПоТипу(Объект потомок, string тип)
    {
        // Данный метод возвращает ближайшего родителя заданного типа. Метод работает через цикл.

        // Пробуем получить родителя объекта
        if (потомок.РодительскийОбъект !=null)
        {
        Объект родительПотомка = потомок.РодительскийОбъект;
            while (родительПотомка.Параметр["Тип"].ToString() != тип)
            {
                родительПотомка = родительПотомка.РодительскийОбъект;
                if (родительПотомка == null)
                    {
                        return null;
                    }                
            }
            return родительПотомка;
        }
        else
        {
            return null;
        }
        
    }
    private List<Объект> ПолучитьДочерниеОбъектыРекурсивно(Объект родитель)
    {
        // Проверка на наличие у родителя дочерних объектов
        Объекты потомки = родитель.ДочерниеОбъекты;
        List<Объект>временныйСписок = new List<Объект>();
        временныйСписок.Add(родитель);
        if (потомки != null)
        {
            foreach(Объект потомок in потомки)
            {   
                временныйСписок.AddRange(ПолучитьДочерниеОбъектыРекурсивно(потомок));
            }
            return временныйСписок;
        }
        else
        {
        	return временныйСписок;
        }        	
    }

    private List<Объект> ПолучитьСотрудниковПодразделения(Объект подразделение)
    {
        // Используя рекурсивное получение дочерних объектов проходим по списку дочерних объектов
        // и отфильтровываем только те, которые относятся к людским ресурсам

        List<Объект> человеческиеРесурсы = new List<Объект>();

        foreach (Объект ресурс in ПолучитьДочерниеОбъектыРекурсивно(подразделение))
        {
            if (ресурс.СвязанныйОбъект["Человек"] != null)
            {
                if (ресурс.СвязанныйОбъект["Человек"].Тип.ПорожденОт("Пользователь"))
                {
            	   человеческиеРесурсы.Add(ресурс);
                }
            }
        }
        return человеческиеРесурсы;
    }
    
    public void ОбновитьДатуПоследнегоИзмененияПроцентаВыполнения()
    {
        // Получаем объект, в котором произошло изменение процента выполнения        
    	Объект проект = ТекущийОбъект;
    	
    	//Открываем проект на изменение
    	проект.Изменить();
    	проект.Параметр["Дата последнего изменения процента выполнения"] = DateTime.Now;
    	проект.Сохранить();
    }

    // Класс для хранения данных
    public class Data
    {
        public string видРабот {get; set;}
        public string фио {get; set;}
        public string заказчик {get; set;}

        public string корневойПроект {get; set;}
        public string наименованиеРодителя {get; set;}
        public string наименованиеРабот {get; set;}
        public string процентВыполнения {get; set;}
        public DateTime начало {get; set;}
        public DateTime окончание {get; set;}
        public DateTime датаПоследнегоИзменения {get; set;}
    }

}
