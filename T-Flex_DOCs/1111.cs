using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using TFlex.DOCs.Model.Macros;
using TFlex.DOCs.Model.Macros.ObjectModel;

public class Macro : MacroProvider
{
    public Macro(MacroContext context)
        : base(context)
    {
    }
    public string[] recurringSearch(string guid)
    {
        // Находим изделие по его guid
        Объект izd = НайтиОбъект("Электронная структура изделий", Условие("Guid", "=", guid));

        // Получаем списко родительских объектов данного изделия
        Объекты родители = izd.РодительскиеОбъекты;

        // Счетчик для присвоения значений элементам массива
        int counter = 0;

        // Получаем длинну списка для использования этого значения в ветвлении рекурсии
        int length = родители.Count();

        // Инициализируем список, в котором будут храниться значения guid родительских объектов
        string [] список = new string[length];

        // Условие выхода из рекурсии
        if (родители.Count == 0)
        {   
            // Возвращает нулевой список
            return список;
        }
        else
        {
            // Проход по каждому элементу списка родительских объектов, полученных на данном шаге рекурсии
            foreach (var родитель in родители)
            {
                // Получение guid текущего элемента
                string гуид = родитель.Параметр["Guid"].ToString();
                список[counter++] = гуид;
                

                // Получение рекурсией родителей текущего элемента

                string[] списокРодителей = recurringSearch(гуид);

                // Инициализация нового списка, который будет включать в себя "список" и "списокРодителей"
                string[] суммарныйСписок = new string[список.Count() + списокРодителей.Count()];

                // Далее, производим присвоение элементов списка суммарномуСписку
                for (int i = 0; i < список.Count(); i = i + 1)
                {
                    суммарныйСписок[i] = список[i];
                }

                // Далее, производим присвоение элементов спискаРодителей суммарномуСписку
                for (int i = 0; i < списокРодителей.Count(); i = i + 1)
                {
                    суммарныйСписок[i + список.Count()] = списокРодителей[i];
                }

                // А теперь присваиваем переменной "Список" итоговый массив данных
                список = суммарныйСписок;



            }
            return список;
        }
    }

    public override void Run()
    {
    	/* Проверка алгоритма для получения названия изделий, которые относятся к текущему изделию
        Принцип работы в том, чтобы используя алгоритм рекурсии, пройти по дереву всех родительских объектов и отобразить все объекты, которые относятся к типу изделия */

        Объект дсе = ТекущийОбъект;
        string сообщение = "";

        string[] listOfProduct= recurringSearch(дсе.Параметр["Guid"].ToString());

        int counter = 0;
        string message = "";

        foreach (var guid in listOfProduct)
        {
            Объект изделие = НайтиОбъект("Электронная структура изделий", Условие("Guid", "=", guid));
            if (изделие.Тип == "Изделие")
            {
                ++counter;
            }
            message = изделие.Параметр["Наименование"] + " " + изделие.Параметр["Обозначение"] + "\n";
            сообщение = сообщение + message;
        }
        
        Сообщение("Список всех родительских ДСЕ", сообщение);
        
        // Инициализация массива с отфильтрованными данными
        string [] списокИзделий = new string [counter];

        counter = 0;
        сообщение = "";

        foreach (var guid in listOfProduct)
        {
            Объект изделие = НайтиОбъект("Электронная структура изделий", Условие("Guid", "=", guid));
            if (изделие.Тип == "Изделие")
            {
                списокИзделий[counter++] = изделие.Параметр["Guid"].ToString();
                message = изделие.Параметр["Наименование"] + " " + изделие.Параметр["Обозначение"] + "\n";
                сообщение = сообщение + message;
            }
        }
        if (сообщение != "")
        {
            Сообщение("Список изделий", сообщение);
        }
        else
        {
            Сообщение ("Список изделий", "Изделия среди родителей отсутствуют");
        }


        // Далее отфильтровываем те записи, которые не относятся к типу объекта "Изделие"

        
        

    }
}
